## 数据库的特点
数据共享、数据独立、减少数据冗余、避免数据不一致和加强数据保护

## 锁

### 行锁
行锁，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。

### 表锁
表锁，和行锁相对应，给这个表加上锁。


### 共享锁（S锁）
共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。


### 排他锁（X锁）
用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。

如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

### 乐观锁
乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

### 悲观锁
与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。


## 视图
视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。

1. 视图能简化用户操作
2. 视图使用户能以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
4. 视图能够对机密数据提供安全保护
5. 适当的利用视图可以更清晰地表达查询

```sql
CREATE VIEW 视图名(列1，列2...)
AS SELECT (列1，列2...)
FROM ...;
```

## 触发器
触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

```sql
Create trigger trigger_name trigger_time trigger_event on tb_name for each row trigger_stmt;
```
trigger_time ：触发器的触发事件，可以为before（在检查约束前触发）
或after（在检查约束后触发）；

trigger_event：是触发器的触发事件，包括insert、update和delete；

tb_name： 表示建立触发器的表名，就是在哪张表上建立触发器

trigger_stmt： 触发器的程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句；

FOR EACH ROW：表示任何一条记录上的操作满足触发事件都会触发该触发器。

例子：
```sql
create trigger trigger01 after update on g for each ROW-- 创建触发器
```

### 三大范式
第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。

第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）

第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。

第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

## 存储过程
存储过程是一些预编译的SQL语句，执行效率比较高
一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
可以一定程度上确保数据安全

## 事务
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
### Atomic(原子性)
一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。（oracle通过redo和undo日志保证）

### Consistency(一致性)
应用系统从一个正确的状态到另一个正确的状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，比如打破了原有的一些约束，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

### Isolation(隔离性)
指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

### Durability(持久性)
指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

## 读取限制
### 脏读（读取未提交数据）
事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。

### 不可重复读（前后多次读取，数据内容不一致）
在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。

### 幻读（前后多次读取，数据总量不一致）
在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。


## drop、delete与truncate分别在什么场景之下使用？
不再需要一张表的时候，用drop
想删除部分数据行时候，用delete，并且带上where子句
保留表而删除所有数据的时候用truncate

## 什么是视图？以及视图的使用场景有哪些？

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

只暴露部分字段给访问者，所以就建一个虚表，就是视图。
查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 数据库三级模式
数据库系统由外模式、模式和内模式构成。外模式是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图；模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。内模式也称存储模式，是数据物理结构和存储方式的描述。

## 数据库关系运算
数据库常用的关系运算为三种：
1、选择。
2、投影。
3、连接。 
（1）选择，是从二维表中选出符合条件的记录，它是从行的角度对关系进行的运算。
（2）投影，是从二维表中选出所需要的列，它是从列的角度对关系进行的运算。
（3）连接，是同时涉及到两个二维表的运算，它是将两个关系在给定的属性上满足给定条件的记录连接起来而得到的一个新的关系。

## 数据库应用设计

### 需求分析设计
形成需求说明书

### 概念设计阶段
形成概念数据模型（作为进一步设计数据库的依据）

### 逻辑设计阶段
形成逻辑数据模型（从 ER 图向关系模式转换、关系视图设计、模式规范化）

### 物理设计阶段
形成数据库内部模型（此时涉及具体软件硬件环境）。

## 隔离级别
### 读未提交（Read Uncommitted）
可以读到未提交的内容
### 读已提交（Read Committed）
只能读到已经提交了的内容，但不要求可重复读。比如，在事务两次读取一个数据项期间，另一个事务更新了该数据并提交。
### 可重复读（Repeated Read）
在一个事务两次读取一个数据项期间，其他事务不得更新该数据
### 可串行化（Serializable）
在这个事务持续期间，禁止其他事务对该表执行插入,更新和删除操作.所有并发问题都可以避免，但性能十分低下

## 索引
索引的优点： 
1、通过创建唯一性的索引，可以保证表中数据的唯一性; 
2、加速数据的检索速度; 
3、加快表与表之间的连接; 
4、在使用分组与排序数据检索时，可以显著检索分组与排序的时间; 
5、在查询的过程中使用优化隐藏器，提供系统性能。

缺点： 
1、创建索引需要时间，且随着数据量的增加而增加; 
2、索引需要占用物理空间;
3、当对表中数据进行修改时，索引也要动态维护，降低了数据的维护速度。

### 索引是什么
索引是对数据库表中一列或多列的值进行排序的一种结构。

### 索引的种类有哪些
普通索引：加速查询
唯一索引：加速查询 + 列值唯一 + 可以为null
主键索引：加速查询 + 列值唯一 + 不可为null + 表中只有一个
组合索引：多列值组成一个索引，专用于组合搜索，效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索
### 什么数据应该添加索引？
Where子句中经常使用的字段应该创建索引

分组字段或者排序字段应该创建索引

两个表的连接字段应该创建索引

存储空间固定的字段更适合选作索引的关键字

占用存储空间少的字段更适合选作索引的关键字 与字符串相比，整数字段更适合

### 哪些数据不适合作为索引？
更新频繁的字段不适合创建索引

不会出现在where子句中的字段
### mysql索引的数据结构是什么？
一般使用B+树做索引
### 你还知道其他的索引类型吗？
Hash索引 B树索引

## 多表联合查询
### 笛卡尔积
,连接
把一个表中的每个元素都和另一表中的每个元素进行组合
最后用where子句限定具体条件

### 自然连接
自然连接只考虑在两个关系模式中都出现的属性上取值相同的元组对
```sql
select name,course_id
from instructor natural join teaches
```
类等价于
```sql
select name,course_id
from instructor,teaches
where instructor.ID=teaches.ID
```

但笛卡尔积会把共有属性列显示两次，自然连接只显示一次
### 外连接
保留未匹配上的元组。比如student代表学生信息，takes代表学生选课信息。如果直接用natural join，则会丢失没有选课的学生。如果用外连接，则可以保留未选课的学生信息。
* 左外连接(left outer join)：只保留出现在左外连接运算之前（左边）的关系中的元组
* 右外连接(right outer join)：只保留出现在右外连接运算之后（右边）的关系中的元组
* 全外连接(full outer join)：保留出现在两个关系中的元组

#### 左外连接例子
相比而言，为了与外连接运算相区分，不保留未匹配上元组的连接运算称为内连接

```sql
select *
from student natural left outer join takes;
```

这样查询出的结果中，对于未选课的学生对应的只出现在takes关系模式中的属性上取空值

右外连接和左外连接是对称的，上面的查询可以写成
```sql
select *
from takes natural right outer join student;
```
不过属性的出现顺序不同

#### 全外连接
既可以显示未选课的学生，也可以显示没有人选的课
```sql
select * from
students natural full join takes;
```
---

on子句可以和外连接一起使用，下述查询和`student natural left outer join takes`的查询是相同，不过属性ID在结果中出现两次
```sql
select *
from student left outer join takes on student.ID=takes.ID;
```

### 连接类型和条件
为了把常规连接和外连接区分开来，SQL中把常规连接称作内连接。这样的连接子句使用inner join，不过inner是可选的，直接写join默认就是内连接

## 其他细节
不能使用比较操作符测试 NULL 值，例如=、<或<>。我们必须使用 IS NULL 和 IS NOT NULL 操作符。

不该删除的被删除是删除异常，该删除的未被删除是删除失败

主键与索引：
1. 主键唯一标识一条记录，不能重复的，不允许为空；索引 该字段没有重复值但可以有一个空值
2. 主键用于保证数据完整性；索引用于提高查询排序的速度
3. 主键只能有一个；一个表可以有多个索引

主键约束可以创建表级约束和列级约束，但是主键不能定义在表级或者列级

JDBC四种驱动方式：jdba-odbc桥接、本地API驱动、网络协议驱动和本地协议驱动

数据库中可能存在不一致的数据，主要有以下三个方面：
A.数据冗余；
B.并发控制不当；
C.故障或者错误

一个表只能有一个聚集索引和多个非聚集索引

## mysql性能优化
### 为什么要优化
系统的吞吐量瓶颈往往出现在数据库的访问速度上

随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
数据是存放在磁盘上的，读写速度无法和内存相比
### 如何优化
设计数据库时：数据库表、字段的设计，存储引擎
利用好MySQL自身提供的功能，如索引等
横向扩展：MySQL集群、负载均衡、读写分离
SQL语句的优化（收效甚微）

