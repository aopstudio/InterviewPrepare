## 大O表示法
大O表示法指出了最糟糕情况下的运行时间

## 优先队列

STL中的优先队列是采用堆来实现的

### 队列
队列的链式存储结构成为链队列，它是限制仅在表头删除和表尾插入的单链表，队头在链头位置。队尾在链尾以便插入结点

### 稳定排序和不稳定排序
1. 稳定排序

Bubble Sort: 只比较相邻元素，相同就不换。

Insertion Sort：有序小序列中逐个插入元素，从小序列末端开始比较，这样元素的相对位置是不变的。

Merge Sort：大小不变不换，相对位置不变

基数排序：低位先排，再收集，直到高位。稳定。

2. 不稳定排序

Selection Sort：每个位置选当前元素最小的，这样元素排序依靠相对位置，

Quick Sort：快排会打乱相同元素顺序（反过来）

希尔排序

Heap Sort：父节点选择元素会破坏稳定性，父节点交换会打乱顺序

## 栈
### 使用栈计算后缀表达式
扫描后缀表达式，如果是操作数，入栈。如果是符号，从栈中弹出两个操作数进行计算后再压回栈。

## 排序
### 概念
1) 稳定性：两个关键字同等的元素，排序前后相对的顺序不变。说明不稳定性只要举出反例即可。
   * 具有稳定性的算法：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序
   * 不稳定的算法：希尔排序、快速排序、简单交换排序、堆排序
2) 内部排序：在排序期间元素全部存放在内存中。
3) 外部排序：在排序期间元素无法全部同时存放在内存中，必须根据需要不断地在内存、外村之间移动。外部排序一般是文件太大，必须存放在磁盘上。


### 插入排序
1) 直接插入排序
   * 特点：待排序数组一部分是有序的，另一部分是无序的。
   * 时间效率：当数组元素有序时，$f(n)=O(n)$。一般情况下，$f(n)=O(n^2)$。
  
2) 折半插入排序
  * 主要针对直接插入排序的定位算法进行优化。定位更快，插入不变。
  * 时间效率：$f(n)=O(n^2)$。

3) 希尔排序
   * 设置步长d将表分块，在不同块中使用直接插入排序，逐步缩小d指到1。
   * 不稳定的算法
   * 仅适用于顺序存储的线性表
   * 时间效率：较佳情况下$f(n)=O(n^{1.3})$，最坏情况$f(n)=O(n^2)$。

### 交换排序
1) 冒泡排序
   * 时间效率：当数组元素有序时，$f(n)=O(n)$。一般情况下$f(n)=O(n^2)$。
2) 快速排序
   * 通过一趟排序将排序表划分为左右两部分，使得左边所有元素小于右边所有元素。  
   从前往后查看元素，标记为i；从后往前查看元素，标记为j。  
   先从j开始，如果a[j]>a[i],则j--；否则swap（a[i],a[j]）,并将主动权给到i。  
   从i开始后，如果a[j]>a[i],则i++；否则swap（a[i],a[j]）,并将主动权还给j。  
   最后直到满足一轮排序的要求。  

   * 效率：当数组元素有序时，$f(n)=O(n^2)$。一般情况下，$f(n)=O(n*log_2n)$
   * 在快排中，不会产生有序序列，但每趟排序会将一个元素放到最终位置上。

### 选择排序
1) 简单选择排序
   * 每一趟选一个最小的放到最前面

2) 堆排序
   * 堆的定义：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足其中一条：  
     1) $L(i)\leqslant L(2i)$且$L(i)\leqslant L(2i+1)$
     2) $L(i)\geqslant L(2i)$且$L(i)\geqslant L(2i+1)$
  
   * 小根堆：最小元素存放在根结点中，对任意非根结点，它的值$\geqslant$其双亲结点的值。
   * 堆排序：一种树形排序方法，将$L[1...n]$看作一棵完全二叉树的顺序存储结构。
   * 堆的构造：先按初始序列建造成完全二叉树的形式，再进行调整，**反复调整**。
    * 堆的删除：只能删除堆顶元素，删除前先将最后一个元素和堆顶元素交换，再向下调整。
    * 堆的插入：插入在堆的末端，再向上调整。
    * 空间复杂度：$O(1)$
    * 时间复杂度：建堆时间$O(n)$，调整时间$O(h)$。排序时间始终是$O(nlog_2n)$。

### 归并排序
  * 归并：将两个或两个以上的有序表组合成一个新的有序表。
  * 空间复杂度：$O(n)$
  * 时间复杂度：每趟归并$O(n)$，归并次数$log_2n$。最终时间$O(nlog_2n)$。

优点：
* 归并排序的效率达到了巅峰：时间复杂度为O(nlogn)，这是基于比较的排序算法所能达到的最高境界
* 归并排序是一种稳定的算法（即在排序过程中大小相同的元素能够保持排序前的顺序，3212升序排序结果是1223，排序前后两个2的顺序不变），这一点在某些场景下至关重要
* 归并排序是最常用的外部排序方法（当待排序的记录放在外存上，内存装不下全部数据时，归并排序仍然适用，当然归并排序同样适用于内部排序）

### 基数排序
  * 多关键字排序思想。对单关键字采用“分配”和“收集”两种操作。
  * r是辅助存储空间，即r个队列。n是n个元素。
  * 空间复杂度：$O(r)$
  * 时间复杂度：$O(d(n+r))$ d是关键字位数

### 总结
1） 快速排序和堆排序相比，选择堆排序的理由：
  * 快排需要使用递归栈，堆排序辅助空间只有$O(1)$。


### 广度优先搜索
类似于二叉树的层次遍历

没有往回退的情况，因此不是一个递归的算法。

需要借助一个辅助队列，以记忆正在访问的顶点的下一层顶点

伪代码如下
```c
bool visited[MAX_VERTEX_NUM];   //访问标记数组
void BFSTraverse(Graph G) {
    //对图G进行广度优先遍历，设访问数为visit()
    for(i=0;i<G.vexnum;++i) //访问标记数组初始化
        visited[i]=FALSE;   
    InitQueue(Q);   //初始化辅助队列Q
    for(i=0;i<G.vexnum;++i) //从0号顶点开始遍历
        if(!visited[i]) //对每个连通分量调用一次BFS
            BFS(G,i);   //v_i_未访问过，从v_i_开始BFS
}
void BFS(Graph G,int v) {
    //从顶点v触发，广度优先遍历图G，算法借助一个辅助队列Q
    visit(v);   //访问初始顶点v
    visited[v]=TRUE;    //对v做已访问标记
    Enqueue(Q,v);   //顶点v入队列
    while(!isEmpty(Q)) {
        DeQueue(Q,v);   //顶点v出队列
        for(w=FirstNeighnor(G,v);w>=0;w=NextNeighbor(G,v,w)) {  //检测v所有邻接点
            if(!visited[w]) {   //w为v的尚未访问的邻接顶点
                visit[w];   //访问顶点w
                visited[w]=TRUE;    //对w做已访问标记
                EnQueue(Q,w);   //顶点w入队列
            }
        }
    }
}
```

### 深度优先搜索
类似于树的先序遍历

```c
bool visited[MAX_VERTEX_NUM];   //访问标记数组
void DFSTraverse(Graph G) {
    //对图G进行深度优先遍历，访问函数为visit()
    for(v=0;v<G.vexnum;++v)
        visited[v]=FALSE;   //初始化已访问标记数据
    for(v=0;v<G.vexnum;++v) //本代码中是从v=0开始遍历
        if(!visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){
    //从顶点v出发，采用递归思想，深度优先遍历图G
    visit(v);   //访问顶点v
    visited[v]=TRUE;    //设已访问标记
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w]){    //w为u的尚未访问的邻接顶点
            DFS(G,w);
        }   
}
```
