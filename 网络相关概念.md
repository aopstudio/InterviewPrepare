## DNS详细过程
1. 检查浏览器缓存中是否缓存过该域名对应的IP地址
2. 如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP
3. 向本地域名解析服务系统发起域名解析的请求
4. 本地域名解析服务器向根域名解析服务器发起域名解析请求
5. 根域名服务器返回顶级域名解析服务器地址
6. 本地域名服务器向顶级服务器发起解析请求
7. 顶级域名服务器返回权威dns服务器地址
8. 本地域名服务器询问权威域名服务器
9. 权威域名服务器向本地域名服务器返回IP地址
10. 本地域名服务器返回IP地址给用户
11. 用户通过IP地址发起HTTP请求
12. 服务器解析请求，并返回数据到用户

## HTTP1.0 HTTP 1.1主要区别

### 1.1 长链接

HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
### 1.2 节约带宽

HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。

这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。

另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础

### 1.3 支持HOST域
HTTP1.0是没有host域的，HTTP1.1才支持这个参数。

## HTTP1.1与HTTP 2.0的主要区别 

### 多路复用

### 二进制分帧

### 首部压缩

### 服务器推送

## arp协议的作用
将IP地址转换为MAC地址

## cookie是怎样被设置到浏览器的（HTTP响应首部字段）
1. 客户端K  通过浏览器L  第一次访问  服务器F
2. 服务器F  在HTTP通过set-cookie头部设置了一个标志客户端K的字符串回送到 客户端K
3. 客户端K的浏览器L检测到响应头部有set-cookie这个HTTP头部后，将他的值存储在硬盘中。

## HTTP2.0和1.0区别
HTTP2.0采用二进制传输数据，采用多路复用，压缩了报文头部，客户端在发起请求后服务器可以主动向客户端推送相关的资源，更加安全

## WebSocket特点
websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端双工通信。websocket弥补了HTTP不支持长连接的特点


## http 响应码

200("OK")
一切正常。实体主体中的文档（若存在的话）是某资源的表示

301("Moved Permanently")
当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。

304("Not Modified")
没有修改，直接读取本地缓存

400("Bad Request")
客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。

404("Not Found") 和410("Gone")
当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。

409("Conflict")
当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。

500("Internal Server Error")
服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。

## 端口号范围
（1）公认端口（WellKnownPorts）

从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。

（2）注册端口（RegisteredPorts）

从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。

（3）动态和/或私有端口（Dynamicand/orPrivatePorts）

从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。

## 地址
A.在A类地址中，10.0.0.0到10.255.255.255是私有地址。所以应该是私有地址。
B.10.2.255.255的粗体字部分为主机号，主机号全为1的才是广播地址，10.255.255.255是广播地址。
C.对的这个地址主机号既不全为1，也不全为0，网络号也属于ABC类里的A类，所以是有效的。
D.10的2进制是0000 1010，所以是A类地址。

A类IP段：0.0.0.0 到 127.255.255.255 (0 段和 127 段不使用 )。

B类IP段：128.0.0.0 到 191.255.255.255，

C类IP段：192.0.0.0 到 223.255.255.255。

在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：
A类地址：10.0.0.0～10.255.255.255
B类地址：172.16.0.0～172.31.255.255
C类地址：192.168.0.0～192.168.255.255

## Cookie和Session的区别
1、存储位置不同
cookie的数据信息存放在客户端浏览器上。

session的数据信息存放在服务器上。

2、存储容量不同
单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。

对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。

3、存储方式不同
cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。

session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。

4、隐私策略不同
cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。

session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。

5、有效期上不同
开发可以通过设置cookie的属性，达到使cookie长期有效的效果。

session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。

6、服务器压力不同
cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。

session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。

7、浏览器支持不同
假如客户端浏览器不支持cookie：

cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。

运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。


8、 跨域
域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者跨域资源共享。

## HTTP 请求报文头部
* User-Agent：产生请求的浏览器类型。
* Accept：客户端可识别的响应内容类型列表;
* Accept-Language：客户端可接受的自然语言;
* Accept-Encoding：客户端可接受的编码压缩格式;
* Accept-Charset：可接受的应答的字符集;
* Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;（必选）
* Connection：连接方式(close 或 keep-alive);
* Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;
* 请求包体：在POST方法中使用。
* Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
* If-Modified-Since：文档的最后改动时间

## HTTP 响应头
* Allow 服务器支持哪些请求方法（如GET、POST等）。
* Content-Encoding 文档的编码（Encode）方法。
* Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。
* Content-Type 表示后面的文档属于什么MIME类型。
* Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
* Expires 应该在什么时候认为文档已经过期，从而不再缓存它。
* Last-Modified 文档的最后改动时间。
* Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。
* Server 服务器名字。
* Set-Cookie 设置和页面关联的Cookie。
* ETag：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。
* Cache-Control：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。

## http 状态码
* 1** 信息，服务器收到请求，需要请求者继续执行操作
* 2** 成功，操作被成功接收并处理
* 3** 重定向，需要进一步的操作以完成请求
    * 301 Moved Permanently。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
    * 302 Moved Temporarily。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
    * 304 Not Modified。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
* 4** 客户端错误，请求包含语法错误或无法完成请求
    * 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
    * 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
    * 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
    * 404 Not Found 请求的资源不存在，例如，输入了错误的URL
* 5** 服务器错误，服务器在处理请求的过程中发生了错误
    * 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
    * 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

## HTTPS
SSL (Secure Sockets Layer) 是用来保障你的浏览器和网站服务器之间安全通信，免受网络“中间人”窃取信息。
1.当你的浏览器向服务器请求一个安全的网页(通常是 https://)
2.服务器就把它的证书和公匙发回来
3.浏览器检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的。
4.浏览器使用公钥加密了一个随机对称密钥，包括加密的URL一起发送到服务器
5.服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。
6.服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页了

## HTTP请求
名称 |功能
----|------
GET	| 请求页面，并返回页面内容
HEAD	|类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
POST	|大多用于提交表单或者上传文件，数据包括在请求体中
PUT	 |从客户端向服务器传送的数据取代指定文档中的内容
DELETE	|请求服务器删除指定的页面
CONNECT	|把服务器当作跳板，让服务器代替客户端访问其他网页
OPTIONS	|允许客户端查看服务器的性能
TRACE	|回显服务器收到的请求，主要用于测试或者诊断

## 路由器和交换机的区别
路由器工作在网络层，根据IP地址寻址，交换机工作在数据链路层，根据MAC地址寻址。路由器可以隔绝广播域，交换机只能隔绝冲突域不能隔绝广播域

## TCP为什么比UDP可靠
三次握手、流量控制、拥塞控制、四次挥手
### 拥塞控制
慢启动和快恢复

## TCP上的应用层协议
HTTP,FTP,SMTP,SSH,Telnet,POP3

## UDP上的应用层协议
NFS（网络文件系统）
TFTP
SNMP(Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理
DHCP
NTP(Network Time Protocol，网络时间协议) ，用于网络同步
BOOTP(Boot Protocol，启动协议) ，应用于无盘设备

## 浏览器输入www.abc.com之后发生了什么，整体流程

## 图片和html文件是否是一起传输
HTTP1.x里不是的，先请求HTML，再解析HTML并请求文件，HTTP2.0可以以push的方式在传输HTML的同时传输图片

## CSMA/CD
CSMA/CD是可抢占的半双工介质访问控制协议

## http 请求包含哪几个部分
请求行、请求头、请求体
### 请求行
请求方法字段、URL字段和HTTP协议版本
例如：GET /index.html HTTP/1.1
get方法将数据拼接在url后面，传递参数受限

请求方法：
GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

### 请求头
请求头(key value形式)
User-Agent：产生请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：主机地址

请求头和请求体之间有一个空行
### 请求体
post方法中，会在请求体中传送数据

## SYN Flood
传统的TCP连接中服务器在第二次握手即发送SYN+ACK响应时进入半开连接状态，此时会分配一些资源维护半开连接。攻击者可以大量伪造HTTP请求使得服务器不断分配资源给半开连接，从而无法正常提供服务。

解决方法：使用SYN Cookie，第二次连接时不分配资源，而是生成一个Cookie并返回客户端，客户端在第三次握手时能提供这个Cookie才真正分配资源建立连接